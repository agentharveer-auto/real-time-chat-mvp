from fastapi import APIRouter, WebSocket, WebSocketDisconnect, Depends, HTTPException\nfrom fastapi.responses import HTMLResponse\nfrom sqlalchemy.orm import Session\nfrom typing import List, Dict\nimport asyncio\nimport json\nfrom ..database import get_db\nfrom ..models import User, Room, Message\nfrom ..auth import decode_access_token\nfrom ..schemas import MessageCreate\n\nrouter = APIRouter()\n\n# In-memory store of active connections per room (room_id -> list of WebSocket)\nactive_connections: Dict[int, List[WebSocket]] = {}\n\n\nasync def get_user_from_token(token: str, db: Session) -> User:
    payload = decode_access_token(token)
    if not payload or 'sub' not in payload:
        return None
    user_id = int(payload['sub'])
    return db.query(User).filter(User.id == user_id).first()
\n\n@router.websocket("/ws/{room_id}")\ndef websocket_endpoint(room_id: int, websocket: WebSocket, db: Session = Depends(get_db)):\n    # Token must be supplied as a query parameter: /ws/{room_id}?token=...\n    token = websocket.query_params.get('token')\n    if not token:\n        return HTTPException(status_code=400, detail="Missing token")\n    # Note: FastAPI WebSocket endpoints run in a coroutine, so token validation happens after acceptance in a simple MVP.\n    import asyncio\n    user = asyncio.run(get_user_from_token(token, db))\n    if not user:\n        asyncio.run(websocket.close(code=1008))\n        return\n\n    if room_id not in active_connections:\n        active_connections[room_id] = []\n    active_connections[room_id].append(websocket)\n    asyncio.create_task(websocket.accept())\n    try:\n        while True:\n            data = asyncio.run(websocket.receive_text())\n            payload = {"content": data}  # simple string broadcast
            # Persist message
            new_message = Message(content=payload['content'], user_id=user.id, room_id=room_id)
            db.add(new_message)\n            db.commit()\n            db.refresh(new_message)\n            # Broadcast to all in room
            for conn in list(active_connections[room_id]):\n                if conn is not websocket:\n                    try:\n                        await conn.send_json({"user": user.username, "content": payload['content'], "timestamp": str(new_message.timestamp)})\n                    except Exception:\n                        pass\n    except WebSocketDisconnect:\n        pass\n    finally:\n        if room_id in active_connections and websocket in active_connections[room_id]:\n            active_connections[room_id].remove(websocket)\n